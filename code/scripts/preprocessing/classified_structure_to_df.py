#!/usr/bin/env python3



import pandas as pd
from datetime import datetime
import os
import sys
from pathlib import Path

# Add the local source directory to path
sys.path.insert(0, os.path.abspath('./code'))
from code.source.config.paths import Dirs
from source.utils.files import  get_newest_file

def classified_structure_to_df(input_dir:str|Path|Dirs.Images = Dirs.Images.HURH, output_dir:str|Path|Dirs.Images = Dirs.Annotations.POST_CLASSIFICATION):
    """
    Converts a manually classified folder structure of images into a CSV 
    combining classification labels with original metadata.

    This function expects the input directory to be organized by category folders 
    (e.g., `input_dir/category_name/image.png`). It extracts image-category pairs 
    and merges them with metadata from a pre-existing CSV generated by `convert_to_csv`. 
    The result is saved as a timestamped CSV in the `output_dir`.

    Parameters
    ----------
    input_dir : str | Path | ImageDirs, optional
        Root directory containing manually sorted image folders. Each subfolder represents a class/category.
        Defaults to `ImageDirs.HURH`.

    output_dir : str | Path | ImageDirs, optional
        Directory to save the resulting merged CSV file. Defaults to `Dirs.Annotations.POST_CLASSIFICATION`.

    Output CSV Columns
    ------------------
    - category         : Name of the category folder the image was sorted into
    - filename         : Name of the image file
    - subdirectory     : Echo study folder (from original metadata)
    - eco_datetime     : Timestamp parsed from subdirectory name
    - image_datetime   : Timestamp parsed from filename
    - image_id         : Patient or study identifier parsed from filename

    Notes
    -----
    - The original metadata is retrieved from the latest CSV file in `Dirs.Annotations.CONVERT`.
    - The resulting CSV is named `classified_structure_YYYY_MM_DD_HH_MM_SS.csv`.
    - If no images are found in the input folder, no CSV is created.
    """
 

    output_dir=Path(output_dir)
    print(f"Input directory: {input_dir}")
    print(f"Output directory: {output_dir}")

    # Ensure output directory exists

    output_dir.mkdir(parents=True, exist_ok=True)

    categories_images= []
    for category_path in Path(input_dir).iterdir():
        if category_path.is_dir():
            for image_path in category_path.iterdir():
                if image_path.is_file():
                    categories_images.append((category_path.name, image_path.name))
    
    if not categories_images:
        print("No files to analyze. CSV won't be created.")
        return
    
    # Create DataFrame from the classified structure
    df_classified = pd.DataFrame(categories_images, columns=["category", "filename"])

    # Load most recent original structure CSV
    pre_classification_dir = Dirs.Annotations.CONVERT
    #TODO: check there is a csv
    original_dirs_structure = pd.read_csv(get_newest_file(pre_classification_dir))
    original_dirs_structure = original_dirs_structure[[
        'subdirectory', 'eco_datetime', 'filename', 'image_datetime', 'image_id']]

    # Merge new class info with original metadata on filename
    df_classified = pd.merge(left=df_classified,
                             right=original_dirs_structure,
                             how="left", on="filename")

    # Generate timestamped filename
    now = datetime.now().strftime('%Y_%m_%d_%H_%M_%S')
    output_file = output_dir / f"classified_structure_{now}.csv"
    # Save DataFrame
    df_classified.to_csv(output_file, index=False)
    print(f"CSV created at: {output_file}")


if __name__ == '__main__':
    classified_structure_to_df()
